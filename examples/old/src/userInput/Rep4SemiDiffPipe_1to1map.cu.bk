#ifndef __Rep4SemiDiffPipe_1to1map_CU
#define __Rep4SemiDiffPipe_1to1map_CU


/* *** MODULE TYPE IMPLEMENTATION FILE ***
 * 
 * Notes to user on usage:
 * 1) This should be the ONLY Mercator file that you modify.
 * 
 * 2) To write output to a channel from within a run() fcn:
 * 	   push(item, `nodeIdx', Out::channelname), where
 * 	  'item' is the item to be written, 'nodeIdx' is the current node's index variable (no single quotes) 
 * 	  passed in as a parameterand 'channelname' is the name
 * 	  given to the channel in the input spec 
 * 	  (which can be found in the comment above the run() header,
 * 	  or in the .cuh header file associated with this implementation).
 * 
 * 3) To access user-defined data from within run() fcn 
 *    (only works if set in user Driver file):
 * 	Full app data: get_appUserData()
 * 	Per-module-type data: this->get_userData()
 * 	Per-module-instance data: this->get_nodeUserData(nodeIdx)
 * 
 * 4) When using multiple threads per item:
 *      -To access thread's offset relative to other threads assigned
 *        to same input item, call eltOffset(threadIdx.x) .
 *      -To access correct output-channel slot, accounting for 
 *        offset, pass offset as third parameter to push() function: 
 *        push(..., ..., eltOffset(threadIdx.x)).
 * 
 * 5) When using multiple items per thread:
 *      -To access number of items assigned to each thread,  *         call this->itemsPerThread(threadIdx.x) .
 *      -To access input items and nodes, use array notation:
  *       inputItems[i] or nodes[i], where 0 <= i < this->itemsPerThread() .
 * 
 */


////  module Begin(PipeEltT[128] -> accept1<PipeEltT>:?1, accept2<PipeEltT>, accept3<PipeEltT>, accept4<PipeEltT> | 1 : 1)
__device__
void Rep4SemiDiffPipe_1to1map::Begin::run(::PipeEltT inputItem, unsigned char nodeIdx)
{
  // duplicate item
  ::PipeEltT inputItemDup = inputItem;

  // init curand state for input items
  curandState_t *state1 = new curandState_t;
  curand_init(blockDim.x * blockIdx.x + threadIdx.x,  /*  seed */ 
              0,  /*  sequence num */
              0,  /*  offset in seq */
              state1);
  inputItem.set_randState(state1);

  curandState_t *state2 = new curandState_t;
  curand_init(blockDim.x * blockIdx.x + threadIdx.x,  /*  seed */ 
              0,  /*  sequence num */
              0,  /*  offset in seq */
              state2);
  inputItemDup.set_randState(state2);

#if 0
  // push downstream: distribute according to desired skew
  if(inputItem.get_ID() % REPPIPE_SKEWFACTOR == 0)
    push(inputItem, nodeIdx, Out::accept1);
  else
    push(inputItemDup, nodeIdx, Out::accept2);
#endif

  int channel;
  switch(inputItem.get_ID() % REPPIPE_SKEWFACTOR)
  {
    case 0:
      channel = Out::accept1;
      break;
    case 1:
      channel = Out::accept2;
      break;
    case 2:
      channel = Out::accept3;
      break;
    case 3:
      channel = Out::accept4;
      break;
    default:
      channel = Out::accept1;
  }

    push(inputItem, nodeIdx, channel);
#if 0
  // replicate every input to both pipelines
  push(inputItem, nodeIdx, Out::accept1);
  push(inputItemDup, nodeIdx, Out::accept2);
#endif
	
}


////  module A(PipeEltT[128] -> accept<PipeEltT>:?1 | 1 : 1)
__device__
void Rep4SemiDiffPipe_1to1map::A::run(::PipeEltT inputItem, unsigned char nodeIdx)
{
  ///// computation: 
  //  do NUM_OPTS rounds of Black-Scholes calculations
//  constexpr int NUM_OPTS = 1;
  int num_opts = inputItem.get_workIters();

  //  parameters for BlackScholes fcn call;
  //   both hold results (passed by value)
  float callResult = inputItem.get_floatResult();
  float putResult = 1.0f;

  // item's state for PRNG
  curandState *randState = inputItem.get_randState();

  // call BlackScholes fcn
  doBlackScholes_fast(callResult, putResult, num_opts, randState);

  // store result in item (addition combo is arbitrary)
  inputItem.set_floatResult(callResult + putResult);

  ///// filtering: 
  //  filter out item if its ID is in upper filterRate-fraction of
  //  bounded (node-specific) range; else push item downstream
  auto nodeData = get_nodeUserData(nodeIdx);
  float fr = nodeData->get_filterRate();
  int ub = nodeData->get_upperBound();

  // border b/t filtered (above) and forwarded (below) items
  int thresh = (1 - fr) * ub;

    // debug
//    printf("Running item w/ID %d, range upper-bd %d, filter rate: %.3f, filter upper-bd %d\n",
//    inputItem.get_ID(), ub, fr, thresh);

  bool passThrough = inputItem.get_ID() < thresh;
  if(passThrough)
    push(inputItem, nodeIdx, Out::accept);	
	
	
}


////  module B(PipeEltT[128] -> accept<PipeEltT>:?1 | 1 : 1)
__device__
void Rep4SemiDiffPipe_1to1map::B::run(::PipeEltT inputItem, unsigned char nodeIdx)
{
  ///// computation: 
  //  do NUM_OPTS rounds of Black-Scholes calculations
//  constexpr int NUM_OPTS = 1;
  int num_opts = inputItem.get_workIters();

  //  parameters for BlackScholes fcn call;
  //   both hold results (passed by value)
  float callResult = inputItem.get_floatResult();
  float putResult = 1.0f;

  // item's state for PRNG
  curandState *randState = inputItem.get_randState();

  // call BlackScholes fcn
  doBlackScholes_fast(callResult, putResult, num_opts, randState);

  // store result in item (addition combo is arbitrary)
  inputItem.set_floatResult(callResult + putResult);

  ///// filtering: 
  //  filter out item if its ID is in upper filterRate-fraction of
  //  bounded (node-specific) range; else push item downstream
  auto nodeData = get_nodeUserData(nodeIdx);
  float fr = nodeData->get_filterRate();
  int ub = nodeData->get_upperBound();

  // border b/t filtered (above) and forwarded (below) items
  int thresh = (1 - fr) * ub;

    // debug
//    printf("Running item w/ID %d, range upper-bd %d, filter rate: %.3f, filter upper-bd %d\n",
//    inputItem.get_ID(), ub, fr, thresh);

  bool passThrough = inputItem.get_ID() < thresh;
  if(passThrough)
    push(inputItem, nodeIdx, Out::accept);	
}


////  module C(PipeEltT[128] -> accept<PipeEltT>:?1 | 1 : 1)
__device__
void Rep4SemiDiffPipe_1to1map::C::run(::PipeEltT inputItem, unsigned char nodeIdx)
{
  ///// computation: 
  //  do NUM_OPTS rounds of Black-Scholes calculations
//  constexpr int NUM_OPTS = 1;
  int num_opts = inputItem.get_workIters();

  //  parameters for BlackScholes fcn call;
  //   both hold results (passed by value)
  float callResult = inputItem.get_floatResult();
  float putResult = 1.0f;

  // item's state for PRNG
  curandState *randState = inputItem.get_randState();

  // call BlackScholes fcn
  doBlackScholes_fast(callResult, putResult, num_opts, randState);

  // store result in item (addition combo is arbitrary)
  inputItem.set_floatResult(callResult + putResult);

  ///// filtering: 
  //  filter out item if its ID is in upper filterRate-fraction of
  //  bounded (node-specific) range; else push item downstream
  auto nodeData = get_nodeUserData(nodeIdx);
  float fr = nodeData->get_filterRate();
  int ub = nodeData->get_upperBound();

  // border b/t filtered (above) and forwarded (below) items
  int thresh = (1 - fr) * ub;

    // debug
//    printf("Running item w/ID %d, range upper-bd %d, filter rate: %.3f, filter upper-bd %d\n",
//    inputItem.get_ID(), ub, fr, thresh);

  bool passThrough = inputItem.get_ID() < thresh;
  if(passThrough)
    push(inputItem, nodeIdx, Out::accept);	
	
}


////  module D(PipeEltT[128] -> accept<PipeEltT>:?1 | 1 : 1)
__device__
void Rep4SemiDiffPipe_1to1map::D::run(::PipeEltT inputItem, unsigned char nodeIdx)
{
  ///// computation: 
  //  do NUM_OPTS rounds of Black-Scholes calculations
//  constexpr int NUM_OPTS = 1;
  int num_opts = inputItem.get_workIters();

  //  parameters for BlackScholes fcn call;
  //   both hold results (passed by value)
  float callResult = inputItem.get_floatResult();
  float putResult = 1.0f;

  // item's state for PRNG
  curandState *randState = inputItem.get_randState();

  // call BlackScholes fcn
  doBlackScholes_fast(callResult, putResult, num_opts, randState);

  // store result in item (addition combo is arbitrary)
  inputItem.set_floatResult(callResult + putResult);

  ///// filtering: 
  //  filter out item if its ID is in upper filterRate-fraction of
  //  bounded (node-specific) range; else push item downstream
  auto nodeData = get_nodeUserData(nodeIdx);
  float fr = nodeData->get_filterRate();
  int ub = nodeData->get_upperBound();

  // border b/t filtered (above) and forwarded (below) items
  int thresh = (1 - fr) * ub;

    // debug
//    printf("Running item w/ID %d, range upper-bd %d, filter rate: %.3f, filter upper-bd %d\n",
//    inputItem.get_ID(), ub, fr, thresh);

  bool passThrough = inputItem.get_ID() < thresh;
  if(passThrough)
    push(inputItem, nodeIdx, Out::accept);	
}


////  module E(PipeEltT[128] -> accept<PipeEltT>:?1 | 1 : 1)
__device__
void Rep4SemiDiffPipe_1to1map::E::run(::PipeEltT inputItem, unsigned char nodeIdx)
{
  ///// computation: 
  //  do NUM_OPTS rounds of Black-Scholes calculations
//  constexpr int NUM_OPTS = 1;
  int num_opts = inputItem.get_workIters();

  //  parameters for BlackScholes fcn call;
  //   both hold results (passed by value)
  float callResult = inputItem.get_floatResult();
  float putResult = 1.0f;

  // item's state for PRNG
  curandState *randState = inputItem.get_randState();

  // call BlackScholes fcn
  doBlackScholes_fast(callResult, putResult, num_opts, randState);

  // store result in item (addition combo is arbitrary)
  inputItem.set_floatResult(callResult + putResult);

  ///// filtering: 
  //  filter out item if its ID is in upper filterRate-fraction of
  //  bounded (node-specific) range; else push item downstream
  auto nodeData = get_nodeUserData(nodeIdx);
  float fr = nodeData->get_filterRate();
  int ub = nodeData->get_upperBound();

  // border b/t filtered (above) and forwarded (below) items
  int thresh = (1 - fr) * ub;

    // debug
//    printf("Running item w/ID %d, range upper-bd %d, filter rate: %.3f, filter upper-bd %d\n",
//    inputItem.get_ID(), ub, fr, thresh);

  bool passThrough = inputItem.get_ID() < thresh;
  if(passThrough)
    push(inputItem, nodeIdx, Out::accept);	
	
}


////  module End(PipeEltT[128] -> accept<PipeEltT>:?1 | 1 : 1)
__device__
void Rep4SemiDiffPipe_1to1map::End::run(::PipeEltT inputItem, unsigned char nodeIdx)
{
  // destroy inputItem's curand state
  curandState_t *state = inputItem.get_randState();
  if(state) delete state;
	
  // push downstream
  push(inputItem, nodeIdx, Out::accept);	
	
}



#endif	// __Rep4SemiDiffPipe_1to1map_CU

