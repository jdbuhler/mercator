#ifndef __BlastApp_CU
#define __BlastApp_CU

/* *** MODULE TYPE IMPLEMENTATION FILE ***
 * 
 * Notes to user on usage:
 * 1) This should be the ONLY Mercator file that you modify.
 * 
 * 2) To write output to a channel from within a run() fcn:
 * 	   node->push(item, Out::channelname), where
 * 	  'item' is the item to be written, and 'channelname' is the name
 * 	  given to the channel in the input spec 
 * 	  (which can be found in the comment above the run() header,
 * 	  or in the .cuh header file associated with this implementation).
 * 
 * 3) To access user-defined data from within run() fcn 
 *    (only works if set in user Driver file):
 * 	Full app data: get_appUserData()
 * 	Per-module-type data: this->get_userData()
 * 	Per-module-instance data: node->get_userData()
 * 
 * 4) When using multiple threads per item:
 *      -To access thread's offset relative to other threads assigned
 *        to same input item, call eltOffset(threadIdx.x) .
 *      -To access correct output-channel slot, accounting for 
 *        offset, pass offset as third parameter to push() function: 
 *        push(..., ..., eltOffset(threadIdx.x)).
 * 
 */


////  module SeedMatch(int[128] -> outStream<point>:?1 | 4 : 1)
__device__
void BlastApp::SeedMatch::run(int* inputItems, Mercator::ModuleInstance<int, SeedMatch>** nodes)
{
  const int  *qHash = get_appUserData()->qHash;
  const Base *db = get_appUserData()->database;

  int myNumItems = this->itemsPerThread(threadIdx.x);

  for(int i=0; i < myNumItems; ++i)
  {

    int seed = (int)(( db[inputItems[i] + STRING_BUFF] ) << 8) | ((int)( db[inputItems[i] + STRING_BUFF + 1] ) );
    int query = qHash[seed];

    if (query != -1)
      nodes[i]->push(point(inputItems[i], query), Out::outStream);
  }
	
}


////  module SeedEnum(point[128] -> outStream<point>:?16 | 4 : 1)
__device__
void BlastApp::SeedEnum::run(::point* inputItems, Mercator::ModuleInstance<::point, SeedEnum>** nodes)
{
  int myNumItems = this->itemsPerThread(threadIdx.x);

  for(int i=0; i < myNumItems; ++i)
  {

    if(inputItems[i].query >= 0) 
    {
      nodes[i]->push(inputItems[i], Out::outStream);
    }
    else
    {
      const int *qHits = get_appUserData()->qHits;

      int qPtr = -inputItems[i].query;

      int a = 0;
      do
      {
        nodes[i]->push(point(inputItems[i].db, qHits[qPtr + a]), 
            Out::outStream, a++);
      }
      while(qHits[qPtr + a] != -1 && a != 16); 
    }

  }
}


////  module SmallExt(point[2048] -> outStream<point>:?1 | 4 : 1)
__device__
void BlastApp::SmallExt::run(::point* inputItems, Mercator::ModuleInstance<::point, SmallExt>** nodes)
{
  int myNumItems = this->itemsPerThread(threadIdx.x);

  for(int i=0; i < myNumItems; ++i)
  {
    //__syncthreads();
    //for(int i = 0; i < 1000000; ++i) { }

    const Base *query = get_appUserData()->query + STRING_BUFF * 4 + inputItems[i].query;
    const Base *db    = get_appUserData()->database + STRING_BUFF + inputItems[i].db;

    int qbyte = query[-1];
    int dbyte = db[-1];

    int nmatchesL = 0;
    while(nmatchesL < 3)
    {
      int mask = 0x03 << (2 * nmatchesL);
      if(((qbyte & 0x06) >> 1) == ((dbyte & mask) >> (2 * nmatchesL))) {
        ++nmatchesL;
        qbyte = query[-nmatchesL - 1];
      }
      else {
        break;
      }
    }


    qbyte = query[8];
    dbyte = db[2];
    int nmatchesR = 0;
    while(nmatchesR < 4) {
      int mask = 0xC0 >> (2 * nmatchesR);
      if(((qbyte & 0x06) << 5) == ((dbyte & mask) << (2 * nmatchesR))) {
        ++nmatchesR;
        qbyte = query[nmatchesR + 8];
      }
      else {
        break;
      }
    }

    if((nmatchesR == 3 || nmatchesL == 3) && nmatchesR != 4)
      //if(inputItems[i].db < 10)
      nodes[i]->push(inputItems[i], Out::outStream);
  }
	
}


////  module UngapExt(point[2048] -> outStream<point>:?1 | 4 : 1)
__device__
void BlastApp::UngapExt::run(::point* inputItems, Mercator::ModuleInstance<::point, UngapExt>** nodes)
{
  int myNumItems = this->itemsPerThread(threadIdx.x);

  for(int i=0; i < myNumItems; ++i)
  {
    const Base *query = get_appUserData()->query + STRING_BUFF * 4 + inputItems[i].query;
    const Base *db    = get_appUserData()->database + STRING_BUFF + inputItems[i].db;

    int tmpScore = 0;
    int highestL = 0;
    int mask; 
    for(int i = 1; i < WINDOW_SIZE; ++i) 
    {
      int qbyte = query[i * -4 + 3];
      int dbyte = db[-i];

      for (int j = 0; j < 4; ++j)
      {
        mask = 0x03 << (2 * j);
        tmpScore += (((qbyte & 0x06) >> 1) == ((dbyte & mask) >> (2 * j)) ? MATCH_SCORE : MISMATCH_SCORE);
        qbyte = query[i * -4 + 3 - j - 1];
        highestL = max(tmpScore, highestL);
      }
    }

    tmpScore = 0;
    int highestR = 0;  
    for(int i = 2; i <= WINDOW_SIZE; ++i) 
    {
      int qbyte = query[i * 4];
      int dbyte = db[i];

      for (int j = 0; j < 4; ++j)
      {
        mask = 0xC0 >> (2 * j);
        tmpScore += (((qbyte & 0x06) << 5) == ((dbyte & mask) << (2 * j)) ? MATCH_SCORE : MISMATCH_SCORE);
        qbyte = query[i * 4 + j + 1];
        highestR = max(tmpScore, highestR);
      }
    }

    if (highestR + highestL >= THRESH_UNGAPPED)
      nodes[i]->push(inputItems[i], Out::outStream);

  }
}



#endif	// __BlastApp_CU

