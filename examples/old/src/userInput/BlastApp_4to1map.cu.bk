#ifndef __BlastApp_4to1map_CU
#define __BlastApp_4to1map_CU


/* *** MODULE TYPE IMPLEMENTATION FILE ***
 * 
 * Notes to user on usage:
 * 1) This should be the ONLY Mercator file that you modify.
 * 
 * 2) To write output to a channel from within a run() fcn:
 * 	   push(item, `nodeIdx', Out::channelname), where
 * 	  'item' is the item to be written, 'nodeIdx' is the current node's index variable (no single quotes) 
 * 	  passed in as a parameterand 'channelname' is the name
 * 	  given to the channel in the input spec 
 * 	  (which can be found in the comment above the run() header,
 * 	  or in the .cuh header file associated with this implementation).
 * 
 * 3) To access user-defined data from within run() fcn 
 *    (only works if set in user Driver file):
 * 	Full app data: get_appUserData()
 * 	Per-module-type data: this->get_userData()
 * 	Per-module-instance data: this->get_nodeUserData(nodeIdx)
 * 
 * 4) When using multiple threads per item:
 *      -To access thread's offset relative to other threads assigned
 *        to same input item, call eltOffset(threadIdx.x) .
 *      -To access correct output-channel slot, accounting for 
 *        offset, pass offset as third parameter to push() function: 
 *        push(..., ..., eltOffset(threadIdx.x)).
 * 
 * 5) When using multiple items per thread:
 *      -To access number of items assigned to each thread,  *         call this->itemsPerThread(threadIdx.x) .
 *      -To access input items and nodes, use array notation:
  *       inputItems[i] or nodes[i], where 0 <= i < this->itemsPerThread() .
 * 
 */


////  module SeedMatch(int[128] -> outStream<point>:?1 | 4 : 1)
__device__
void BlastApp_4to1map::SeedMatch::run(int* inputItems, unsigned char* nodeIdxs)
{
  int myNumItems = this->itemsPerThread(threadIdx.x);

  for(int i=0; i < myNumItems; ++i)
  {
    auto inputItem = inputItems[i];
    auto nodeIdx = nodeIdxs[i];

    const int  *qHash = get_appUserData()->qHash;
    const Base *db = get_appUserData()->database;

    int seed = (int)(( db[inputItem + STRING_BUFF] ) << 8) | ((int)( db[inputItem + STRING_BUFF + 1] ) );
    int query = qHash[seed];

    if (query != -1)
      push(point(inputItem, query), nodeIdx, Out::outStream);

  }
	
}


////  module SeedEnum(point[128] -> outStream<point>:?16 | 4 : 1)
__device__
void BlastApp_4to1map::SeedEnum::run(::point* inputItems, unsigned char* nodeIdxs)
{
  int myNumItems = this->itemsPerThread(threadIdx.x);

  for(int i=0; i < myNumItems; ++i)
  {
    auto inputItem = inputItems[i];
    auto nodeIdx = nodeIdxs[i];

    if(inputItem.query >= 0) 
    {
      push(inputItem, nodeIdx, Out::outStream);
    }
    else
    {
      const int *qHits = get_appUserData()->qHits;

      int qPtr = -inputItem.query;

      int a = 0;
      do
      {
        push(point(inputItem.db, qHits[qPtr + a]), 
            nodeIdx,
            Out::outStream, a++);
      }
      while(qHits[qPtr + a] != -1 && a != 16); 
    }

  }
}


////  module SmallExt(point[2048] -> outStream<point>:?1 | 4 : 1)
__device__
void BlastApp_4to1map::SmallExt::run(::point* inputItems, unsigned char* nodeIdxs)
{
  int myNumItems = this->itemsPerThread(threadIdx.x);

  for(int i=0; i < myNumItems; ++i)
  {
    auto inputItem = inputItems[i];
    auto nodeIdx = nodeIdxs[i];

    const Base *query = get_appUserData()->query + STRING_BUFF * 4 + inputItem.query;
    const Base *db    = get_appUserData()->database + STRING_BUFF + inputItem.db;

    int qbyte = query[-1];
    int dbyte = db[-1];

    int nmatchesL = 0;
    while(nmatchesL < 3)
    {
      int mask = 0x03 << (2 * nmatchesL);
      if(((qbyte & 0x06) >> 1) == ((dbyte & mask) >> (2 * nmatchesL))) {
        ++nmatchesL;
        qbyte = query[-nmatchesL - 1];
      }
      else {
        break;
      }
    }


    qbyte = query[8];
    dbyte = db[2];
    int nmatchesR = 0;
    while(nmatchesR < 4) {
      int mask = 0xC0 >> (2 * nmatchesR);
      if(((qbyte & 0x06) << 5) == ((dbyte & mask) << (2 * nmatchesR))) {
        ++nmatchesR;
        qbyte = query[nmatchesR + 8];
      }
      else {
        break;
      }
    }

    if((nmatchesR == 3 || nmatchesL == 3) && nmatchesR != 4)
      //if(inputItem.db < 10)
      push(inputItem, nodeIdx, Out::outStream);

  }
	
}


////  module UngapExt(point[2048] -> outStream<point>:?1 | 4 : 1)
__device__
void BlastApp_4to1map::UngapExt::run(::point* inputItems, unsigned char* nodeIdxs)
{
  int myNumItems = this->itemsPerThread(threadIdx.x);

  for(int i=0; i < myNumItems; ++i)
  {
    auto inputItem = inputItems[i];
    auto nodeIdx = nodeIdxs[i];

    const Base *query = get_appUserData()->query + STRING_BUFF * 4 + inputItem.query;
    const Base *db    = get_appUserData()->database + STRING_BUFF + inputItem.db;

    int tmpScore = 0;
    int highestL = 0;
    int mask; 
    for(int i = 1; i < WINDOW_SIZE; ++i) 
    {
      int qbyte = query[i * -4 + 3];
      int dbyte = db[-i];

      for (int j = 0; j < 4; ++j)
      {
        mask = 0x03 << (2 * j);
        tmpScore += (((qbyte & 0x06) >> 1) == ((dbyte & mask) >> (2 * j)) ? MATCH_SCORE : MISMATCH_SCORE);
        qbyte = query[i * -4 + 3 - j - 1];
        highestL = max(tmpScore, highestL);
      }
    }

    tmpScore = 0;
    int highestR = 0;  
    for(int i = 2; i <= WINDOW_SIZE; ++i) 
    {
      int qbyte = query[i * 4];
      int dbyte = db[i];

      for (int j = 0; j < 4; ++j)
      {
        mask = 0xC0 >> (2 * j);
        tmpScore += (((qbyte & 0x06) << 5) == ((dbyte & mask) << (2 * j)) ? MATCH_SCORE : MISMATCH_SCORE);
        qbyte = query[i * 4 + j + 1];
        highestR = max(tmpScore, highestR);
      }
    }

    if (highestR + highestL >= THRESH_UNGAPPED)
      push(inputItem, nodeIdx, Out::outStream);

  }
	
}



#endif	// __BlastApp_4to1map_CU

