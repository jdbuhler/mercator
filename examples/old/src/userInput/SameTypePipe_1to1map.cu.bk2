#include "SameTypePipe_1to1map_dev.cuh"

/* *** MODULE TYPE IMPLEMENTATION FILE ***
 * 
 * Notes to user on usage:
 * 1) This should be the ONLY Mercator file that you modify.
 * 
 * 2) To write output to a channel from within a run() fcn:
 *    push(item, `nodeIdx', Out::channelname), where
 *    'item' is the item to be written, 'nodeIdx' is the current 
 *    node's index variable (no single quotes) 
 *    passed in as a parameterand 'channelname' is the name
 *    given to the channel in the input spec 
 *    (which can be found in the comment above the run() header,
 *    or in the .cuh header file associated with this implementation).
 * 
 * 3) To access user-defined data from within run() fcn 
 *    (only works if set in user Driver file):
 *   Full app data: get_appUserData()
 *   Per-module-type data: this->get_userData()
 *   Per-module-instance data: this->get_nodeUserData(nodeIdx)
 * 
 * 4) When using multiple threads per item:
 *     -To access thread's offset relative to other threads assigned
 *       to same input item, call eltOffset(threadIdx.x) .
 *     -To access correct output-channel slot, accounting for 
 *       offset, pass offset as third parameter to push() function: 
 *       push(..., ..., eltOffset(threadIdx.x)).
 * 
 * 5) When using multiple items per thread:
 *     -To access number of items assigned to each thread, 
 *        call this->itemsPerThread(threadIdx.x) .
 *     -To access input items and nodes, use array notation:
 *      inputItems[i] or nodeIdxs[i], where 0 <= i < this->itemsPerThread() .
 * 
 */

#include "BlackScholes/BlackScholes_device.cuh"

namespace Mercator
{
  namespace SameTypePipe_1to1mapNS
  {
    __device__
    void Begin::run(PipeEltT inputItem, InstTagT nodeIdx)
    {
      // init inputItem's curand state
      curandState_t *state = new curandState_t;
      curand_init(blockDim.x * blockIdx.x + threadIdx.x,  /*  seed */
		  0,  /*  sequence num */
		  0,  /*  offset in seq */
		  state);
      inputItem.set_randState(state);
      
      // push downstream
      push(inputItem, nodeIdx, Out::accept); 
    }
    
    __device__
    void A::run(PipeEltT inputItem, InstTagT nodeIdx)
    {            
      ///// computation:
      //  do NUM_OPTS rounds of Black-Scholes calculations
      //  constexpr int NUM_OPTS = 1;
      int num_opts = inputItem.get_workIters();
      
      //  parameters for BlackScholes fcn call;
      //   both hold results (passed by value)
      float callResult = 1.0f;
      float putResult  = 1.0f;
      
      // item's state for PRNG
      curandState *randState = inputItem.get_randState();
      
      // call BlackScholes fcn
      doBlackScholes_fast(callResult, putResult, num_opts, randState);
      
      // store result in item (addition combo is arbitrary)
      inputItem.set_floatResult(callResult + putResult);
      
      ///// filtering:
      //  filter out item if its ID is in upper filterRate-fraction of
      //  bounded (node-specific) range; else push item downstream
      float fr = getParams().filterRate[nodeIdx];
      int ub   = getParams().upperBound[nodeIdx];

      // border b/t filtered (above) and forwarded (below) items
      int thresh = (1.0f - fr) * ub;
      
      bool passThrough = (inputItem.get_ID() < thresh);
      if (passThrough)
	push(inputItem, nodeIdx, Out::accept);
    }
    
    __device__
    void End::run(PipeEltT inputItem, InstTagT nodeIdx)
    {
      // destroy inputItem's curand state
      curandState_t *state = inputItem.get_randState();
      if (state) 
	delete state;
      
      // push downstream
      push(inputItem, nodeIdx, Out::accept);
    }
  } // end namespace SameTypePipe_1to1mapNS
} // end namespace Mercator
