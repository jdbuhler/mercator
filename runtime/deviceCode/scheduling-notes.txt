NOTES ON SCHEDULING AND SIGNAL PROCESSING

A node may fire only if it is ACTIVE and has NO ACTIVE CHILDREN.

Initially, the source is active, and all other nodes are inactive.

An inactive node becomes active when either its data or signal queue
becomes FULL, or when it is explicitly set to flushing mode and
activated by its parent.

  - for the data queue, FULL means that there is insufficient space
    remaining for the previous node to process a full vector width of
    inputs.

  - for the signal queue, FULL means that there is insufficient space
    remaining for the maximum number of signals that could be issued
    by the previous node processing a full vector width of inputs 
    (MAX_SIGNALS_PER_VEC) AND the max # of signals that could
    result from processing one queued signal (MAX_SIGNALS_PER_SIG).
    The former is currently 2, while the latter is currently 1.
    [Defined in Signal.cuh]

An active node becomes inactive when its data and signal queues
become EMPTY

   - EMPTY means less than one full vector width of items in
     the data queue *and* NO queued signals.

[NB: signals are never issued with more credit that the number of
items in the data queue, so it is not possible for the signal queue to
be nonempty but blocked on data that has not yet been issued.]

Fireable nodes are queued in the scheduler.  No node may appear on a
queue more than once.  When no fireable nodes exist in the queue, the
application terminates.

The source enters flushing mode when it cannot request any more data
from the input stream.

CLAIM: the application cannot terminate with data or signals still
queued.

--------------------------

Signals are managed on each edge by a local credit protocol.

A signal is issued with an amount of credit equal to the number
of queued data items that must be processed between the previous
queued signal (if any) and itself.

--------------------------

Firing a node work as follows:

[Note: we are not enforcing full ensembles right now]

PRECONDITION: When a node fires, it is ACTIVE and has NO ACTIVE
CHILDREN.  Therefore, it either 
   * has no queued signals AND >= vector width queued data items, OR
   * has >= 1 queued signal, OR
   * is in flushing mode
AND none of its children have FULL data or FULL signal queues.  Hence,
the node is safe to fire and can make progress.

//
// begin by caching queue sizes and credits in per-thread registers,
// so we don't have to do synchronous updates to them
//

nDataToConsume    = <size of data queue>
nSignalsToConsume = <size of signal queue>

nCredit = nSignalsToconsume == 0 
          ? 0 
          : # of credits in signal at head of signal queue

nDataConsumed    = 0
nSignalsConsumed = 0

// 
// run until we are out of both signals and data, OR a downstream
// node has been activated due to a full queue.
//  


anyDSActive = false

while ((nDataConsumed < nDataToConsume) ||
       (nSignalsConsumed < nSignalsToConsume) && 
       !anyDSActive)

   // credit is relevant only if there are pending signals
   limit = (nSignalsConsumed < nSignalsToConsume 
            ? nCredit : nDataToConsume - nDataConsumed)

   nItems = min(limit, vector width)

   // try to eat up to a vector worth of data (as limit permits)
   // AND write any data or signal outputs that result downstream
   CONSUME data items [nDataConsumed .. nDataConsumed + nItems - 1]

   // If we have a signal pending, see if it's time to consume it
   if (nSignalsToConsume > 0) 
      nCredit -= nItems

      if (nCredit == 0)
        CONSUME signal [nSignalsConsumed] // may generate signals downstream

      if (nSignalsConsumed < nSignalsToConsume) // get credit from next signal
         nCredit = credits from signal [nSignalsConsumed + 1]

      nSignalsConsumed++
               
   for each downstream channel with a FULL data or signal queue,
    activate downstream node
    set anyDSActive true
    
SYNC

// update us queue sizes to reflect cached values
release nDataConsumed data items from data queue
release nSignalsConsumed signals from signal queue

// save cached credit value
if nSignalsConsumed < nSignalsToConsume
   set signal credit at head of queue to nCredit

// if we've consumed all inputs from both queues...
if (nDataConsumed == nDatatoConsume && 
    nSignalsConsumed == nSignalsToConsume)
   
   deactivate node

   if we are flushing
     set flushing and activate all downstream nodes
     unset our flushing flag
